apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ template "fullname" . }}-test"
  labels:
    app: {{ template "fullname" . }}
    chart: "{{ .Chart.Name }}"
    release: "{{ .Release.Name }}"
    heritage: "{{ .Release.Service }}"
    component: "test"
    part-of: {{ template "groupingLabel" . }}
  annotations:
    version: "{{ .Chart.Version }}"
spec:
  parallelism: {{ .Values.job_replicas }}
  backoffLimit: {{ .Values.backoffLimit }}
  template:
    metadata:
      name: "{{ .Release.Name}}"
      labels:
        app: {{ template "fullname" . }}
        chart: "{{ .Chart.Name }}"
        release: "{{ .Release.Name }}"
        heritage: "{{ .Release.Service }}"
        component: "test"
        part-of: {{ template "groupingLabel" . }}
      annotations:
        version: "{{ .Chart.Version }}"
    spec:
      initContainers:
     {{- if .Values.getClientToken.enabled }}
      - name: get-client-token
        image: {{ .Values.getClientToken.image }}
        imagePullPolicy: {{ .Values.getClientToken.imagePullPolicy | default "IfNotPresent" }}
        env:
          - name: ONEZONE_HOST
            value: https://{{ .Values.getClientToken.onezone_host }}
          - name: ONEZONE_BASIC_AUTH
            value: {{ .Values.getClientToken.basicAuth }}
        command:
          - "sh"
          - "-c"
          - >
            token="tooShortToken!" ;
            while : ; do
              echo "Waiting for token... " ;
              token=$(curl -k -u $ONEZONE_BASIC_AUTH -X POST -d "" -H "content-type: application/json" $ONEZONE_HOST/api/v3/onezone/user/client_tokens | tee curl_log | jq -r ".token");
              cat curl_log ;
              if echo $token | grep -E "^[A-Za-z0-9]{80,}" ; then break ; else sleep 1 ; fi ;
            done ;
            echo "$token" > /monitor/token ;
        volumeMounts:
        - mountPath: /monitor
          name: monitor
      {{- end }}
      - name: wait-for-redis
        image: {{ .Values.wait_for.image }}
        imagePullPolicy: {{ .Values.wait_for.imagePullPolicy | default "IfNotPresent" }}
        env:
        - name: REDIS_HOST
          value: {{ .Values.syncBarrier.redisHost | default (printf "%s-redis" .Release.Name) | quote }}
        - name: REDIS_PORT
          value: {{ .Values.syncBarrier.redisPort | quote }}
        command:
          # In this rare case, we can't use kube-api server to check redis availability since this job will be started >1000 times
          # and it might be equivalent to a DOS attack on kube-api server.
          - "sh"
          - "-c"
          - >
            echo "Waiting for redis server to start. Checking every second. " ;
            while ! nc -z -w1 -v $REDIS_HOST $REDIS_PORT ; do sleep 1 ; done ; 
      hostname: "{{ .Chart.Name }}-results"
      restartPolicy: Never
      containers:
      - name: compute
        image: {{ .Values.compute.image }}
        imagePullPolicy: {{ .Values.compute.imagePullPolicy | default "IfNotPresent" }}
        env:
          - name: dataMountPoint
            value: {{ .Values.compute.dataMountPoint | quote }}
          - name: spaceName
            value: {{ .Values.compute.spaceName | quote }}
          - name: jobReplicas
            value: {{ .Values.job_replicas | quote }}
  {{- range $name, $value := .Values.compute.env }}
  {{- if not (empty $value) }}
          - name: {{ printf "env_%s" $name | quote }}
            value: {{ $value | quote }}
  {{- end }}
  {{- end }}
        command:
          - "/usr/bin/env"
          - "{{ .Values.compute.shell }}"
          - "-c"
          - |-
            set -e ;
            trap "{ echo 1 > /monitor/ordinal_number ; echo 1 > /monitor/wait-for-compute-prep-barrier ; echo 1 > /results/prep-starting ; echo 1 > /results/prep-ended ; echo 1 > /monitor/wait-for-compute-run-barrier ; echo 1 > /results/compute-starting ; echo 1 > /results/compute-ended ; echo 1 > /monitor/wait-for-compute-clean-barrier ; echo 1 > /results/clean-starting ; echo 1 > /monitor/wait-for-compute-clean-barrier ; echo 1 > /results/clean-ended ; echo 1 > /monitor/oneclient-can-exit ; }" EXIT ;
            work_dir="$dataMountPoint/$spaceName" ;
            printf "$(date) " ; echo "Waiting for job ordinal number..." ;
            while [ ! -f /monitor/ordinal_number ] ; do sleep 1 ; done ;
            export jobId=$(cat /monitor/ordinal_number) ; echo "Ordinal number acquired: jobId=$jobId" ;
{{ .Values.compute.command | indent 12 }}
            printf "$(date) " ; echo "Waiting for oneclient..." ;
            while [ ! -f /monitor/oneclient-started ] ; do sleep 1 ; done ;
            printf "$(date) " ; echo "Oneclient ready." ;
            printf "$(date) " ; echo "Reached compute point." ;
            printf "$(date) " ; echo "Waiting for all other jobs to reach this point before running sysbench prepare." ;
            echo 1 > /monitor/wait-for-compute-prep-barrier ;
            while [ ! -f /monitor/wait-for-all-jobs-prep-barrier ] ; do sleep 1 ; done ;
            echo 1 > /results/prep-starting ;
            if type prepare 2>/dev/null | head -n 1 | grep -q 'function'; then prepare ; else echo "Prepare step was not defined." ; fi ;
            echo 1 > /results/prep-ended ;
            printf "$(date) " ; echo "Waiting for all other jobs to reach this point before running sysbench run." ;
            echo 1 > /monitor/wait-for-compute-run-barrier ;
            while [ ! -f /monitor/wait-for-all-jobs-run-barrier ] ; do sleep 1 ; done ;
            echo 1 > /results/compute-starting ;
            if type compute 2>/dev/null | head -n 1 | grep -q 'function'; then compute ; else echo "Compute step was not defined." ; fi ;
            echo 1 > /results/compute-ended ;
            printf "$(date) " ; echo "Waiting for all other jobs to reach this point before running cleaning procedure." ;
            echo 1 > /monitor/wait-for-compute-clean-barrier ;
            while [ ! -f /monitor/wait-for-all-jobs-clean-barrier ] ; do sleep 1 ; done ;
            echo 1 > /results/clean-starting ;
            if type clean 2>/dev/null | head -n 1 | grep -q 'function'; then clean ; else echo "Clean step was not defined." ; fi ;
            echo 1 > /results/clean-ended ;
            printf "$(date) " ; echo "The compute container finished." ;
            printf "$(date) " ; echo "Signalling oneclient to finish." ;
            echo 1 > /monitor/oneclient-can-exit ;
        volumeMounts:
        - mountPath: {{ .Values.compute.dataMountPoint }}:shared
          name: oneclient
        - mountPath: /monitor
          name: monitor
        - mountPath: /results
          name: results
      - name: oneclient
        image: {{ .Values.oneclient.image }}
        imagePullPolicy: {{ .Values.oneclient.imagePullPolicy | default "IfNotPresent" }}
        env:
          - name: ONECLIENT_INSECURE
            value: {{ .Values.oneclient.insecure | quote }}
          - name: ONECLIENT_ACCESS_TOKEN # change this to your access token
            value: {{ .Values.oneclient.accessToken | quote }}
          - name: ONECLIENT_PROVIDER_HOST # change this to your provider ip or FQDN
            value: {{ .Values.oneclient.provider_host| quote }}
          - name: experiment
            value: {{ .Values.grafanaPrefix.experiment }}
          - name: date
            valueFrom:
              configMapKeyRef:
                name: {{ template "fullname" . }}-config
                key: date
          - name: release
            value: {{ .Values.grafanaPrefix.release }}
          - name: dc
            value: {{ .Values.grafanaPrefix.dc }}
          - name: cluster
            value: {{ .Values.grafanaPrefix.cluster }}
          - name: MY_NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
          - name: MY_POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: MY_POD_NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.name
          - name: GRAFANA_URL
            value: tcp://{{ .Values.oneclient.grafanaUrl }}
          - name: MOUNT_POINT
            value: {{ .Values.oneclient.mountPoint }}
        command:
          - "sh"
          - "-c"
          - >
            trap "{ echo 1 > /monitor/oneclient-started ; }" EXIT ;
            {{- if .Values.getClientToken.enabled }}
            ONECLIENT_ACCESS_TOKEN=$(cat /monitor/token) ;
            export ONECLIENT_ACCESS_TOKEN ;
            {{- end }}
            args="test";
            graphite_prefix="{{ .Values.oneclient.graphite_prefix }}" ;
            printf "Grafana prefix: $graphite_prefix\n" ;
            printf "Oneclient version: " ; oneclient --version ;
            echo "Running Oneclient. Upon succesful mount will list all avilable spaces..." ;
            echo "export ONECLIENT_ACCESS_TOKEN=$ONECLIENT_ACCESS_TOKEN ; export ONECLIENT_PROVIDER_HOST=$ONECLIENT_PROVIDER_HOST; export ONECLIENT_INSECURE=$ONECLIENT_INSECURE ; oneclient {{ .Values.oneclient.args }}" ;
            oneclient {{ .Values.oneclient.args }} ;
            while [ -z "$(ls -A "$MOUNT_POINT" )" ]; do sleep 2 ; done ;
            ls $MOUNT_POINT ;
            echo 1 > /monitor/oneclient-started ;
            while [ ! -f /monitor/oneclient-can-exit ] ; do sleep 2 ; done ;
            oneclient -u "$MOUNT_POINT" ;
            echo "Compute finished, stopping oneclient." ;
        securityContext:
          privileged: true
        volumeMounts:
        - mountPath: {{ .Values.oneclient.mountPoint }}:shared
          name: oneclient
        - mountPath: /monitor
          name: monitor
      - name: results
        image: {{ .Values.resultsGatherer.image }}
        imagePullPolicy: {{ .Values.compute.imagePullPolicy | default "IfNotPresent" }}
        command:
{{ toYaml .Values.resultsGatherer.command | indent 10 }}
        volumeMounts:
        - mountPath: /monitor
          name: monitor
        - mountPath: /results
          name: results
      - name: sync-barrier
        image: {{ .Values.syncBarrier.image }}
        imagePullPolicy: {{ .Values.syncBarrier.imagePullPolicy | default "IfNotPresent" }}
        env:
        - name: REDIS_HOST
          value: "{{ .Release.Name}}-redis"
        - name: REDIS_PORT
          value: {{ .Values.syncBarrier.redisPort | quote }}
        - name: TOTAL_JOBS_COUNT
          value: {{ .Values.job_replicas | quote }}
        command:
          - "bash"
          - "-c"
          - >
            incr() {
              redis_var="$1" ;
              redis_val="" ;
              while : ; do
                printf %b "*2\r\n\$4\r\nINCR\r\n\$"${#redis_var}"\r\n${redis_var}\r\n" >&3 ;
                read -r redis_val <&3 ;
                redis_val=$(printf %b "$redis_val" | cut -f2 -d$ | tr -d "\r:\'") ;
                printf "$(date): " ; echo "Counter increased. $redis_var: <${redis_val}>" ;
                if [ "$redis_val" = "" ] ; then sleep 1 ; else break ; fi ;
              done ;
            } ;
            wait_for_all() {
              redis_var="$1" ;
              redis_val="" ;
              while : ; do
                printf %b "*2\r\n\$3\r\nGET\r\n\$"${#redis_var}"\r\n${redis_var}\r\n" >&3 ;
                read -r redis_val <&3 ;
                read -r redis_val <&3 ;
                redis_val=$(printf %b "$redis_val" | cut -f2 -d$ | tr -d "\r:\'") ;
                printf "$(date): " ; echo "Ready count is $redis_var: <${redis_val}>" ;
                if [ "$redis_val" = "" ] ; then sleep 1 ; else break ; fi ;
              done ;
              printf "$(date): " ; echo "Waiting for all ($TOTAL_JOBS_COUNT) pods to reach a compute point." ;
              while [[ $redis_val -lt $TOTAL_JOBS_COUNT ]] ; do
                printf "$(date): " ; echo "$redis_var: <$redis_val> is less then $TOTAL_JOBS_COUNT" ;
                redis_val="" ;
                while : ; do
                  printf %b "*2\r\n\$3\r\nGET\r\n\$"${#redis_var}"\r\n${redis_var}\r\n" >&3 ;
                  read -r redis_val <&3 ;
                  read -r redis_val <&3 ;
                  redis_val=$(printf %b "$redis_val" | cut -f2 -d$ | tr -d "\r:\'") ;
                  if [ "$redis_val" = "" ] ; then sleep 1 ; else break ; fi ;
                done ;
                sleep 1 ;
              done ;
              echo "Wait ended with $redis_var: <$redis_val>." ;
            } ;
            printf "$(date): " ; echo "Opening port to redis server." ;
            exec 3<>/dev/tcp/${REDIS_HOST}/${REDIS_PORT} ;
            printf "$(date): " ; echo "/dev/tcp/${REDIS_HOST}/${REDIS_PORT}" ;
            printf "$(date): " ; echo "Getting job ordinal number." ;
            incr job_id ; ordinal_number=$redis_val ; 
            if [ $ordinal_number = "" ] ; then printf "$(date): " ; echo "[ERROR] Failed to acquire job ordinal number" ; exit 1 ; fi ;
            printf "$(date): " ; echo "Job ordinal number is: <$ordinal_number>" ;
            echo $ordinal_number > /monitor/ordinal_number ;
            printf "$(date): " ; echo "Waiting for this pod to reach a compute point." ;
            while [ ! -f /monitor/wait-for-compute-prep-barrier ] ; do sleep 2 ; done ;
            incr compute_prep; wait_for_all compute_prep;
            printf "$(date): " ; echo "All $TOTAL_JOBS_COUNT pods reached compute prep point." ;
            echo 1 >  /monitor/wait-for-all-jobs-prep-barrier ;
            while [ ! -f /monitor/wait-for-compute-run-barrier ] ; do sleep 2 ; done ;
            incr compute_run; wait_for_all compute_run;
            printf "$(date): " ; echo "All $TOTAL_JOBS_COUNT pods reached compute run point." ;
            echo 1 >  /monitor/wait-for-all-jobs-run-barrier ;
            while [ ! -f /monitor/wait-for-compute-clean-barrier ] ; do sleep 2 ; done ;
            incr compute_clean; wait_for_all compute_clean;
            printf "$(date): " ; echo "All $TOTAL_JOBS_COUNT pods reached compute clean point." ;
            echo 1 >  /monitor/wait-for-all-jobs-clean-barrier ;
        volumeMounts:
        - mountPath: /monitor
          name: monitor
        # volumeMounts:
        #   - name: podstates
        #     mountPath: /podstates
        #     readOnly: false
      volumes:
        - name: monitor
          emptyDir: {}
        - name: oneclient
          emptyDir: {}
        - name: results
          emptyDir: {}
        # - name: podstates
        #   downwardAPI:
        #     items:
        #       - path: "compute"
        #         fieldRef:
        #           fieldPath: status.containerStatuses